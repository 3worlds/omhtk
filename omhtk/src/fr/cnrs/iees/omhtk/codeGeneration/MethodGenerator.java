/**************************************************************************
 *  OMHTK - One More Handy Tool Kit                                       *
 *                                                                        *
 *  Copyright 2021: Shayne R. Flint, Jacques Gignoux & Ian D. Davies      *
 *       shayne.flint@anu.edu.au                                          *
 *       jacques.gignoux@upmc.fr                                          *
 *       ian.davies@anu.edu.au                                            * 
 *                                                                        *
 *  OMHTK is a bunch of useful, very generic interfaces for designing     *
 *  consistent class hierarchies, plus some other utilities. The kind of  *
 *  things you need in all software projects and keep rebuilding all the  * 
 *  time.                                                                 *
 *                                                                        *
 **************************************************************************                                       
 *  This file is part of OMHTK (One More Handy Tool Kit).                 *
 *                                                                        *
 *  OMHTK is free software: you can redistribute it and/or modify         *
 *  it under the terms of the GNU General Public License as published by  *
 *  the Free Software Foundation, either version 3 of the License, or     *
 *  (at your option) any later version.                                   *
 *                                                                        *
 *  OMHTK is distributed in the hope that it will be useful,              *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *  GNU General Public License for more details.                          *                         
 *                                                                        *
 *  You should have received a copy of the GNU General Public License     *
 *  along with OMHTK.
 *  If not, see <https://www.gnu.org/licenses/gpl.html>.                  *
 *                                                                        *
 **************************************************************************/
package fr.cnrs.iees.omhtk.codeGeneration;

import static fr.cnrs.iees.omhtk.codeGeneration.Comments.*;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import fr.cnrs.iees.omhtk.JavaCode;

/**
 * <p>
 * A simple method code generator for java classes. It does not handle
 * exceptions, nor annotations, and provides only limited support for <a href=
 * "https://docs.oracle.com/javase/tutorial/java/generics/types.html">generic
 * types</a>.
 * </p>
 * <p>
 * Usage:
 * </p>
 * <ol>
 * <li>Get an instance of {@link ClassGenerator}. If it has a superclass or
 * implements interfaces, it will generate instances of {@code MethodGenerator}
 * for every abstract method found in the superclass / interfaces.</li>
 * <li>Get the method generator you want to work with
 * {@code ClassGenerator.getMethod(...)} or
 * {@code ClassGenerator.getMethods()}.</li>
 * <li>Update the method generator as you want, populating it with statements
 * etc.</li>
 * <li>When you call {@code asText(...)} on your {@code ClassGenerator}, it will
 * call this class {@link MethodGenerator#asText(String) asText(...)} method so
 * that all the edits you made in your method generator will be reflected in the
 * generated code. Basically, you should never need to call
 * {@code MethodGenerator.asText(...)} directly - unless you want to generate
 * the code of a single method floating outside of a class.</li>
 * </ol>
 * 
 * @author Jacques Gignoux - 19 d√©c. 2014
 *
 */
public class MethodGenerator implements JavaCode {

	protected String override;
	protected String scope;
	protected boolean isAbstract = false;
	protected String returnType;
	protected String name;
	protected String[] argTypes;
	protected String[] argNames;
	protected List<String> statements = new LinkedList<String>();
	protected String returnStatement = "return null";
	protected Set<String> dependencies = new HashSet<String>();
	protected boolean insertCodeInsertionComment = false;

	private String getLastBit(String s, String regexp) {
		String[] ss = s.split(regexp);
		return ss[ss.length - 1];
	}

	/**
	 * The list of classes this method requires as imports. It is generated by the
	 * constructors from superclass / interfaces and used by the
	 * {@link ClassGenerator} to generate appropriate {@code import} statements.
	 * 
	 * @return the list of dependencies
	 */
	public String[] dependencies() {
		String[] a = new String[dependencies.size()];
		return dependencies.toArray(a);
	}

	/**
	 * Insert code insertion comments in the method body. These are comments telling
	 * the end-user where they can include new code.
	 */
	public void insertCodeInsertionComment() {
		insertCodeInsertionComment = true;
	}

	/**
	 * Constructor from a superclass method. Copies all method information from the
	 * ancestor.
	 * <p>
	 * CAUTION: generic type arguments (ie containing &lt;?&gt; or &lt;T&gt;) are
	 * not supported.
	 * </p>
	 * 
	 * @param method - the ancestor method to generate this one from
	 */
	public MethodGenerator(Method method) {
		super();
		name = method.getName();
		returnType = method.getReturnType().getSimpleName();
		if (returnType.equals("Class"))
			returnType += "<?>";
		override = "@Override";
		int m = method.getModifiers();
		if (Modifier.isPublic(m))
			scope = "public";
		else if (Modifier.isProtected(m))
			scope = "protected";
		else
			scope = "private";
		Class<?>[] ct = method.getParameterTypes();

		Type[] pt = method.getGenericParameterTypes();
		argTypes = new String[pt.length];
		argNames = new String[pt.length];

		for (int i = 0; i < pt.length; i++) {
			String s = pt[i].toString();
			if (s.contains("class "))
				s = getLastBit(s, "class ");
			if (s.contains("interface "))
				s = getLastBit(s, "interface ");
			dependencies.add(s);
			argTypes[i] = ct[i].getSimpleName();
			// TODO: this doesnt work with templates, i.e. Map<ComplexSystem,?>
			if (argTypes[i].equals("Class"))
				argTypes[i] += "<?>";
			argNames[i] = "v" + i;
//			not needed:
//			if (t instanceof ParameterizedType) {
//				ParameterizedType aType = (ParameterizedType) t;
//				Type[] parameterArgTypes = aType.getActualTypeArguments();
//				for(Type parameterArgType : parameterArgTypes){
//		            System.out.println("parameterArgClass = " + parameterArgType);
//		        }
//			}
		}
//		for (int i=0; i<pt.length; i++) {
//			argTypes[i] = pt[i].getSimpleName();
//			if (argTypes[i].equals("Class")) argTypes[i]+="<?>";
//			argNames[i] = "v"+i;
//		}
	}

	/**
	 * Constructor from scratch - self explained parameters.
	 * 
	 * @param scope      ah yes - a nice little scope.
	 * @param returnType ah yes - a nice little returnType.
	 * @param isAbstract ah yes - a nice little isAbstract.
	 * @param name       ah yes - a nice little name.
	 * @param argTypes   ah yes - a nice little argTypes.
	 */
	public MethodGenerator(String scope, boolean isAbstract, String returnType, String name, String... argTypes) {
		super();
		this.scope = scope;
		this.isAbstract = isAbstract;
		this.returnType = returnType;
		this.name = name;
		this.argTypes = argTypes;
		argNames = new String[argTypes.length];
		for (int i = 0; i < argNames.length; i++)
			argNames[i] = "v" + i;
		override = null;
	}

	/**
	 * Constructor from another {@code MethodGenerator}.
	 * 
	 * @param mgen the method generator to clone
	 */
	public MethodGenerator(MethodGenerator mgen) {
		super();
		scope = mgen.scope;
		returnType = mgen.returnType;
		name = mgen.name;
		argTypes = mgen.argTypes.clone();
		argNames = mgen.argNames.clone();
		override = mgen.override;
		statements.addAll(mgen.statements);
		dependencies.addAll(mgen.dependencies);
		insertCodeInsertionComment = mgen.insertCodeInsertionComment;
	}

	/**
	 * Add a statement to this method body.
	 * 
	 * @param statement the statement to add as a String, without the final ";"
	 * @return this instance for agile programming
	 */
	public MethodGenerator setStatement(String statement) {
		statements.add(statement);
		return this;
	}

	/**
	 * Add a return statement <em>at the end</em> of this method. If you want to add
	 * return statements higher in the method body, use
	 * {@link MethodGenerator#setStatement(String) setStatement(...)} instead.
	 * 
	 * @param statement the return statement as a String without the final ";"
	 * @return this instance for agile programming
	 */
	public MethodGenerator setReturnStatement(String statement) {
		returnStatement = statement;
		return this;
	}

	/**
	 * Set an argument name.
	 * 
	 * @param index the rank of the argument name to set
	 * @param name  the name of the argument
	 * @return this instance for agile programming
	 */
	public MethodGenerator setArgumentName(int index, String name) {
		argNames[index] = name;
		return this;
	}

	/**
	 * Set an argument type. Use with caution in the case of inherited methods as
	 * conflicts may arise. Generic types (ie containing &lt;?&gt; or &lt;T&gt;) can
	 * be set here.
	 * 
	 * @param index the rank of the argument type to set
	 * @param type  the type of the argument, possibly including generic types
	 * @return this instance for agile programming
	 */
	public MethodGenerator setArgumentType(int index, String type) {
		argTypes[index] = type;
		return this;
	}

	/**
	 * Set all argument names. Names must come in the proper order to match the
	 * argument types.
	 * 
	 * @param names the list of new argument names
	 * @return this instance for agile programming
	 */
	public MethodGenerator setArgumentNames(String... names) {
		for (int i = 0; i < names.length; i++)
			argNames[i] = names[i];
		return this;
	}

	/**
	 * The name of the method represented by this generator.
	 * 
	 * @return this instance for agile programming
	 */
	public String name() {
		return name;
	}

	/**
	 * Set the return type of this method. Use with caution it the method is
	 * inherited.
	 * 
	 * @param type the return type as a valid java class name or primitive type
	 * @return this instance for agile programming
	 */
	public MethodGenerator setReturnType(String type) {
		returnType = type;
		return this;
	}

	@Override
	public String asText(String indent) {
		StringBuilder result = new StringBuilder(); 
		if (override != null)
			result.append(indent).append(override).append("\n");
		if (returnType == null) // constructors only (never abstract)
			result.append(indent).append(scope).append(" ").append(name).append("(");
		else { // other methods (may be abstract)
			if (isAbstract)
				result.append(indent).append(scope).append(" abstract ").append(returnType)
					.append(" ").append(name).append("(");
			else
				result.append(indent).append(scope).append(" ").append(returnType)
					.append(" ").append(name).append("(");
		}
		if (argTypes != null)
			for (int i = 0; i < argTypes.length; i++) {
				result.append(argTypes[i]).append(" ").append(argNames[i]);
				if (i == argTypes.length - 1)
					;
				else
					result.append(", ");
			}
		if (isAbstract) // no body
			result.append(");\n\n");
		else { // print body
			result.append(") {\n");
			if (insertCodeInsertionComment)
				result.append(indent).append(singleLineComment(startCodeInsertion));
			for (String s : statements) {
				result.append(indent).append(indent).append(s);
				if (s.endsWith(";")||s.endsWith("}")) // do not add ';' when not needed
					result.append("\n");
				else
					result.append(";\n");
			}
			if (returnType == null)
				;
			else if (returnType.equals("void"))
				;
			else if (returnStatement.endsWith(";")||returnStatement.endsWith("}"))
				result.append(indent).append(indent).append(returnStatement).append("\n");
			else
				result.append(indent).append(indent).append(returnStatement).append(";\n");
			if (insertCodeInsertionComment)
				result.append(indent).append(singleLineComment(finishCodeInsertion));
			result.append(indent).append("}\n\n");
		}
		return result.toString();
	}

}
